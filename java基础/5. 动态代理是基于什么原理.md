java 反射机制， 动态代理基于什么原理

反射机制是java语言提供的一种基础功能，赋予程序在**运行时自省**的能力。 （introspect）
通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以**运行时修改类定义**

动态代理是一种方便 运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装RPC调用，面向切面的编程（AOP）

实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似ASM、cglib（基于ADM）、javassist等。

反射，就像一种魔法，引入运行时自省能力，赋予了 Java 语言令人意外的活力，通过运行时操作元数据或对象， Java 可以灵活地操作运行时才能确定的信息。
而动态代理，则是延伸出来的一种广泛应用于产品开发中的技术，很多繁琐的重复编程，都可以被动态代理机制优雅地解决。

### 知识扩展
1.	反射机制 及其演进
		反射提提供了 AccessibleObject.setAccessible(boolean flag)。它的子类也大都重写了这个方法，这里的所谓 accessible 可以理解成修饰成员的 public、protected、private，这意味着我们可以在运行时修改成员的访问限制！
		另一个典型的场景就是绕过API访问控制。我们日常开发是可能被迫要调用内部API去做些事情，比如，自定义的高性能NIO框架需要显式地释放DirectBuffer，使用反射绕开限制是一种常见办法。
		
	
		但是，在Java9之后，这个方法的使用可能会存在一些争议，因为jigsaw项目新增了模块化系统，出于强封装性的考虑，对反射访问进行了限制。
    		Jigsaw 引入了所谓的open的概念，只有当被反射操作的模块和指定的包对反射调用者模块open，才能使用setAccessible；否则，被认为是不合法（illegal）操作。如果我们的实体类是定义在模块里面，我们需要在模块描述符中明确声明
    ```java
		// jvm相关参数 --illegal-access= {permit | warn | deny}
    	module MyEntities {
    		// Open for reflection
			opens com.mycorp to java.persistence;
    	}
    ```

