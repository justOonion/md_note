如何将猜测变成可验证的结论？？？

用户空间 内核态空间
这是操作系统层面的基本概念，操作系统内核、硬件驱动等运行在内核态空间， 具有相对较高的特权；而用户态控价，则是给普通应用和服务使用

当我门使用输入输出流进行读写时，实际上是进行了多次上下文切换，比如应用读取数据时，先切换到内核态将磁盘数据读到内核缓存，在切换到用户态将数据从内核缓存读到用户缓存。

中间经历了两次上下文切换 和 两次copy

写入操作也是类似

应用写入数据时，首先用户态将数据 写到用户缓存，在切换到内核态，将用户缓存数据写到内核缓存，最终写入磁盘

所以这种方式会带来一定的额外开销，会降低IO效率


而基于NIO的 transferTo的实现方式，在Linux 和 Unix 上， 会使用到零拷贝技术，整个拷贝过程 用户空间不需要参与，省去了上下文切换的开销 和 不必要的内存拷贝，进而可能提高应用拷贝性能。注意 transferTo的机制不仅可以用在文件拷贝中，与其类似的，例如读取磁盘文件 然后进行socket发送，同样可以享受这种机制带来的性能和扩展性提高。


前面我在典型回答中提了第三种方式，即Java标准库也提供了文件拷贝方式
如果你这样回答，就一定要小心了，因为很少有问题的答案是仅仅调用某个方法。从面试的角度，面试官往往会追问：既然你提到了标准库，那么他是怎么实现的？有的公司面试官一喜欢追问出名，知道追问到你说不知道。

其实这个问题的答案还真不是那么直观，因为实际上有几个不同的copy方法。

- 在程序中，适用缓存等机制，合理减少IO次数（在网络通信中，如TCP传输，window大小也可以看作是类似思路）。
- 适用 transferTo 等机制，减少上下文切换和额外IO操作
- 尽量减少不必要的转换过程，比如编码器；对象序列化和反序列化，比如操作文本文件或者网络通信，如果不是过程中需要适用文件信息，可以考虑不要将二进制信息准换成字符串，直接传输二进制信息。
