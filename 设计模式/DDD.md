支付流程

先记录交易流水，并标记为 “待执行”！

当两个钱包的加减金额都完成之后，再寄那个交易流水标记为 “成功”

如果两个钱包任意一个加减金额操作失败，则记录状态 “失败”

通过 后台补漏job 拉取状态为失败 或者长时间处于 待执行状态的交易记录，重新执行，或人工介入处理。





先从最简单的方案开始 然后再优化

识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选。
类比一下方法的识别 可以把功能点中涉及的名字，作为候选属性，左后同样进行过滤筛选



### 违反-里氏替换原则 3中情况
1. **子类违背父类声明要实现的功能**：父类中提供的sort() 方法，是按照数量来排序的，而子类重写这个sort()方法时，却按照创建日期进行排序的，那就违反了里氏替换原则
2. **子类违背父类对输入、输出、异常的约定**
   	2.1	 父类某个函数约定：出错返回null,获取数据为空时返回空集合.而子类重载函数后，实现变了,出错抛出异常，获取数据为空时返回null
      	2.2 	父类中某个函数约定：输入可以是任意整数，但子类只允许输入正整数，负数就抛出。**也就是子类对输入的数据校验比父类更加严格**
      	2.3	 父类中某个函数约定：只会抛出ArgumentNullException异常，但子类允许抛出其他异常
3. **子类违背父类注释中所罗列的任何特殊说明**：父类中函数注释说明用户提现金额不得超过余额，而子类重写函数后，针对VIP实现了透支提现功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里氏替换原则的

### 接口隔离原则
**定义**：客户端不应该被强制依赖它不需要的接口

### 依赖反转原则
**定义**：高层模块不依赖低层模块，他们都应该依赖抽象，抽象不应该依赖细节，而细节依赖抽象
在调用链中，高层模块指调用方，低层模块指被调用方







**高内聚**：就是指相近的功能应该放到同一个类中，不相近的功能不应该放到同一个类中。（单一职责原则）
**松耦合**：类之间的关系简单清晰，一个类的代码改动不会导致依赖类的代码改动。类职责单一，而且被依赖的类很少。（依赖注入，接口隔离，基于接口而非实现编程）



### 迪米特法则(最小知识)
每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）

**不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口**



“高内聚、松耦合”“单一职责原则”“接口隔离原则”“基于接口而非实现编程”“迪米特法则”，你能总结一下它们之间的区别和联系吗？





业务系统设计：接口设计、数据库设计、业务模型设计















